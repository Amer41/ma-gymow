"""
This type stub file was generated by pyright.
"""

def next_power_of_2(x): # -> Literal[1]:
    ...

def dict_deep_update(d, u):
    ...

def nested_setitem(obj, dotted_name, value): # -> None:
    ...

def download_to_bytes(url, chunk_size=..., loadbar_length=...): # -> tuple[bytes, str | None]:
    """ download a url to bytes

    if chunk_size is not None, prints a simple loading bar [=*loadbar_length] to show progress (in console and notebook)

    :param url: str or url
    :param chunk_size: None or int in bytes
    :param loadbar_length: int length of load bar
    :return: (bytes, encoding)
    """
    ...

def download_yield_bytes(url, chunk_size=...): # -> Generator[Any, None, None]:
    """ yield a downloaded url as byte chunks

    :param url: str or url
    :param chunk_size: None or int in bytes
    :yield: byte chunks
    """
    ...

def download_to_file(url, filepath, resume=..., overwrite=..., chunk_size=..., loadbar_length=...): # -> None:
    """ download a url

    prints a simple loading bar [=*loadbar_length] to show progress (in console and notebook)

    :type url: str
    :type filepath: str
    :param filepath: path to download to
    :param resume: if True resume download from existing file chunk
    :param overwrite: if True remove any existing filepath
    :param chunk_size: None or int in bytes
    :param loadbar_length: int length of load bar
    :return:
    """
    ...

def reduce_size(data, max_size, extent): # -> tuple[Unknown, list[Unknown]]:
    ...

def grid_slice(amin, amax, shape, bmin, bmax): # -> tuple[tuple[int, int], tuple[Unknown, Unknown]]:
    '''Given a grid with shape, and begin and end coordinates amin, amax, what slice
    do we need to take such that it minimally covers bmin, bmax.
    amin, amax = 0, 1; shape = 4
    0  0.25  0.5  0.75  1
    |    |    |    |    |
    bmin, bmax = 0.5, 1.0 should give 2,4, 0.5, 1.0
    bmin, bmax = 0.4, 1.0 should give 1,4, 0.25, 1.0

    bmin, bmax = -1, 1.0 should give 0,4, 0, 1.0

    what about negative bmin and bmax ?
    It will just flip bmin and bmax
    bmin, bmax = 1.0, 0.5 should give 2,4, 0.5, 1.5

    amin, amax = 1, 0; shape = 4
    1  0.75  0.5  0.25  0
    |    |    |    |    |
    bmin, bmax = 0.5, 1.0 should give 0,2, 1.0, 0.5
    bmin, bmax = 0.4, 1.0 should give 0,3, 1.0, 0.25
    '''
    ...

def get_ioloop(): # -> None:
    ...

def debounced(delay_seconds=..., method=...): # -> (f: Unknown) -> ((*args: Unknown, **kwargs: Unknown) -> None):
    ...


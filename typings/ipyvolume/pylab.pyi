"""
This type stub file was generated by pyright.
"""

_last_figure = ...
_seq_sn = ...
_seq_snm = ...
_doc_snippets = ...
class current:
    figure = ...
    container = ...
    figures = ...
    containers = ...


def clear(): # -> None:
    """Remove current figure (and container)"""
    ...

def controls_light(return_widget=...): # -> list[HBox] | None:
    ...

def figure(key=..., width=..., height=..., lighting=..., controls=..., controls_vr=..., controls_light=..., debug=..., **kwargs): # -> Figure:
    """Create a new figure (if no key is given) or return the figure associated with key

    :param key: Python object that identifies this figure
    :param int width: pixel width of WebGL canvas
    :param int height:  .. height ..
    :param bool lighting: use lighting or not
    :param bool controls: show controls or not
    :param bool controls_vr: show controls for VR or not
    :param bool debug: show debug buttons or not
    :return: :any:`Figure`
    """
    ...

def gcf(): # -> Figure:
    """Get current figure, or create a new one

    :return: :any:`Figure`
    """
    ...

def xlim(xmin, xmax): # -> None:
    """Set limits of x axis"""
    ...

def ylim(ymin, ymax): # -> None:
    """Set limits of y axis"""
    ...

def zlim(zmin, zmax): # -> None:
    """Set limits of zaxis"""
    ...

def xyzlim(vmin, vmax=...): # -> None:
    """Set limits or all axis the same, if vmax not given, use [-vmin, vmax]"""
    ...

def squarelim(): # -> None:
    """Sets all axes with equal aspect ratio, such that the space is 'square'"""
    ...

default_color = ...
default_color_selected = ...
default_size = ...
default_size_selected = ...
@_docsubst
def plot_trisurf(x, y, z, triangles=..., lines=..., color=..., u=..., v=..., texture=...): # -> Mesh:
    """Draws a polygon/triangle mesh defined by a coordinate and triangle indices

    The following example plots a rectangle in the z==2 plane, consisting of 2 triangles:

    >>> plot_trisurf([0, 0, 3., 3.], [0, 4., 0, 4.], 2,
           triangles=[[0, 2, 3], [0, 3, 1]])

    Note that the z value is constant, and thus not a list/array. For guidance, the triangles
    refer to the vertices in this manner::

        ^ ydir
        |
        2 3
        0 1  ---> x dir

    Note that if you want per face/triangle colors, you need to duplicate each vertex.


    :param x: {x}
    :param y: {y}
    :param z: {z}
    :param triangles: numpy array with indices referring to the vertices, defining the triangles, with shape (M, 3)
    :param lines: numpy array with indices referring to the vertices, defining the lines, with shape (K, 2)
    :param color: {color}
    :param u: {u}
    :param v: {v}
    :param texture: {texture}
    :return: :any:`Mesh`
    """
    ...

@_docsubst
def plot_surface(x, y, z, color=..., wrapx=..., wrapy=...): # -> Mesh:
    """Draws a 2d surface in 3d, defined by the 2d ordered arrays x,y,z

    :param x: {x2d}
    :param y: {y2d}
    :param z: {z2d}
    :param color: {color2d}
    :param bool wrapx: when True, the x direction is assumed to wrap, and polygons are drawn between the end end begin points
    :param bool wrapy: simular for the y coordinate
    :return: :any:`Mesh`
    """
    ...

@_docsubst
def plot_wireframe(x, y, z, color=..., wrapx=..., wrapy=...): # -> Mesh:
    """Draws a 2d wireframe in 3d, defines by the 2d ordered arrays x,y,z

    See also :any:`ipyvolume.pylab.plot_mesh`

    :param x: {x2d}
    :param y: {y2d}
    :param z: {z2d}
    :param color: {color2d}
    :param bool wrapx: when True, the x direction is assumed to wrap, and polygons are drawn between the begin and end points
    :param bool wrapy: idem for y
    :return: :any:`Mesh`
    """
    ...

def plot_mesh(x, y, z, color=..., wireframe=..., surface=..., wrapx=..., wrapy=..., u=..., v=..., texture=...): # -> Mesh:
    """Draws a 2d wireframe+surface in 3d: generalization of :any:`plot_wireframe` and :any:`plot_surface`

    :param x: {x2d}
    :param y: {y2d}
    :param z: {z2d}
    :param color: {color2d}
    :param bool wireframe: draw lines between the vertices
    :param bool surface: draw faces/triangles between the vertices
    :param bool wrapx: when True, the x direction is assumed to wrap, and polygons are drawn between the begin and end points
    :param boool wrapy: idem for y
    :param u: {u}
    :param v: {v}
    :param texture: {texture}
    :return: :any:`Mesh`
    """
    ...

@_docsubst
def plot(x, y, z, color=..., **kwargs): # -> Scatter:
    """Plot a line in 3d

    :param x: {x}
    :param y: {y}
    :param z: {z}
    :param color: {color}
    :param kwargs: extra arguments passed to the Scatter constructor
    :return: :any:`Scatter`
    """
    ...

@_docsubst
def scatter(x, y, z, color=..., size=..., size_selected=..., color_selected=..., marker=..., selection=..., grow_limits=..., **kwargs): # -> Scatter:
    """Plots many markers/symbols in 3d

    :param x: {x}
    :param y: {y}
    :param z: {z}
    :param color: {color}
    :param size: {size}
    :param size_selected: like size, but for selected glyphs
    :param color_selected:  like color, but for selected glyphs
    :param marker: {marker}
    :param selection: numpy array of shape (N,) or (S, N) with indices of x,y,z arrays of the selected markers, which can have a different size and color
    :param kwargs:
    :return: :any:`Scatter`
    """
    ...

@_docsubst
def quiver(x, y, z, u, v, w, size=..., size_selected=..., color=..., color_selected=..., marker=..., **kwargs): # -> Scatter:
    """Create a quiver plot, which is like a scatter plot but with arrows pointing in the direction given by u, v and w

    :param x: {x}
    :param y: {y}
    :param z: {z}
    :param u: {u_dir}
    :param v: {v_dir}
    :param w: {w_dir}
    :param size: {size}
    :param size_selected: like size, but for selected glyphs
    :param color: {color}
    :param color_selected: like color, but for selected glyphs
    :param marker: (currently only 'arrow' would make sense)
    :param kwargs: extra arguments passed on to the Scatter constructor
    :return: :any:`Scatter`
    """
    ...

def show(extra_widgets=...): # -> None:
    """Display (like in IPython.display.dispay(...)) the current figure"""
    ...

def animate_glyphs(*args, **kwargs): # -> None:
    """Deprecated: please use animation_control"""
    ...

def animation_control(object, sequence_length=..., add=..., interval=...): # -> HBox | None:
    """Animate scatter, quiver or mesh by adding a slider and play button.

    :param object: :any:`Scatter` or :any:`Mesh` object (having an sequence_index property), or a list of these to control multiple.
    :param sequence_length: If sequence_length is None we try try our best to figure out, in case we do it badly,
            you can tell us what it should be. Should be equal to the S in the shape of the numpy arrays as for instance documented
            in :any:`scatter` or :any:`plot_mesh`.
    :param add: if True, add the widgets to the container, else return a HBox with the slider and play button. Useful when you
            want to customise the layout of the widgets yourself.
    :param interval: interval in msec between each frame
    :return: If add is False, if returns the ipywidgets.HBox object containing the controls
    """
    ...

def gcc(): # -> None:
    """Return the current container, that is the widget holding the figure and all the control widgets, buttons etc."""
    ...

def transfer_function(level=..., opacity=..., level_width=..., controls=..., max_opacity=...): # -> TransferFunctionWidgetJs3:
    """Create a transfer function, see volshow"""
    ...

def plot_isosurface(data, level=..., color=..., wireframe=..., surface=..., controls=..., extent=...): # -> Mesh:
    """Plot a surface at constant value (like a 2d contour)

    :param data: 3d numpy array
    :param float level: value where the surface should lie
    :param color: color of the surface, although it can be an array, the length is difficult to predict beforehand,
                  if per vertex color are needed, it is better to set them on the returned mesh afterwards.
    :param bool wireframe: draw lines between the vertices
    :param bool surface: draw faces/triangles between the vertices
    :param bool controls: add controls to change the isosurface
    :param extent: list of [[xmin, xmax], [ymin, ymax], [zmin, zmax]] values that define the bounding box of the mesh, otherwise the viewport is used
    :return: :any:`Mesh`
    """
    ...

def volshow(data, lighting=..., data_min=..., data_max=..., max_shape=..., tf=..., stereo=..., ambient_coefficient=..., diffuse_coefficient=..., specular_coefficient=..., specular_exponent=..., downscale=..., level=..., opacity=..., level_width=..., controls=..., max_opacity=..., memorder=..., extent=...): # -> Volume:
    """Visualize a 3d array using volume rendering.

    Currently only 1 volume can be rendered.


    :param data: 3d numpy array
    :param origin: origin of the volume data, this is to match meshes which have a different origin
    :param domain_size: domain size is the size of the volume 
    :param bool lighting: use lighting or not, if set to false, lighting parameters will be overriden
    :param float data_min: minimum value to consider for data, if None, computed using np.nanmin
    :param float data_max: maximum value to consider for data, if None, computed using np.nanmax
    :parap int max_shape: maximum shape for the 3d cube, if larger, the data is reduced by skipping/slicing (data[::N]), set to None to disable.
    :param tf: transfer function (or a default one)
    :param bool stereo: stereo view for virtual reality (cardboard and similar VR head mount)
    :param ambient_coefficient: lighting parameter
    :param diffuse_coefficient: lighting parameter
    :param specular_coefficient: lighting parameter
    :param specular_exponent: lighting parameter
    :param float downscale: downscale the rendering for better performance, for instance when set to 2, a 512x512 canvas will show a 256x256 rendering upscaled, but it will render twice as fast.
    :param level: level(s) for the where the opacity in the volume peaks, maximum sequence of length 3
    :param opacity: opacity(ies) for each level, scalar or sequence of max length 3
    :param level_width: width of the (gaussian) bumps where the opacity peaks, scalar or sequence of max length 3
    :param bool controls: add controls for lighting and transfer function or not
    :param float max_opacity: maximum opacity for transfer function controls
    :param extent: list of [[xmin, xmax], [ymin, ymax], [zmin, zmax]] values that define the bounds of the volume, otherwise the viewport is used
    :return:
    """
    ...

def save(filepath, makedirs=..., title=..., all_states=..., offline=..., scripts_path=..., drop_defaults=..., template_options=..., devmode=..., offline_cors=...): # -> None:
    """Save the current container to a HTML file

    By default the HTML file is not standalone and requires an internet connection to fetch a few javascript
    libraries. Use offline=True to download these and make the HTML file work without an internet connection.

    :param str filepath: The file to write the HTML output to.
    :param bool makedirs: whether to make directories in the filename path, if they do not already exist
    :param str title: title for the html page
    :param bool all_states: if True, the state of all widgets know to the widget manager is included, else only those in widgets
    :param bool offline: if True, use local urls for required js/css packages and download all js/css required packages
            (if not already available), such that the html can be viewed with no internet connection
    :param str scripts_path: the folder to save required js/css packages to (relative to the filepath)
    :param bool drop_defaults: Whether to drop default values from the widget states
    :param template_options: list or dict of additional template options
    :param bool devmode: if True, attempt to get index.js from local js/dist folder
    :param bool offline_cors: if True, sets crossorigin attribute of script tags to anonymous

    """
    ...

def movie(f=..., function=..., fps=..., frames=..., endpoint=..., cmd_template_ffmpeg=..., cmd_template_gif=..., gif_loop=...): # -> str:
    """Create a movie (mp4/gif) out of many frames

    If the filename ends in `.gif`, `convert` is used to convert all frames to an animated gif using the `cmd_template_gif`
    template. Otherwise `ffmpeg is assumed to know the file format`.

    Example:

    >>> def set_angles(fig, i, fraction):
    >>>     fig.angley = fraction*np.pi*2
    >>> # 4 second movie, that rotates around the y axis
    >>> p3.movie('test2.gif', set_angles, fps=20, frames=20*4,
            endpoint=False)

    Note that in the example above we use `endpoint=False` to avoid to first and last frame to be the same

    :param str f: filename out output movie (e.g. 'movie.mp4' or 'movie.gif')
    :param function: function called before each frame with arguments (figure, framenr, fraction)
    :param fps: frames per seconds
    :param int frames: total number of frames
    :param bool endpoint: if fraction goes from [0, 1] (inclusive) or [0, 1) (endpoint=False is useful for loops/rotatations)
    :param str cmd_template_ffmpeg: template command when running ffmpeg (non-gif ending filenames)
    :param str cmd_template_gif: template command when running imagemagick's convert (if filename ends in .gif)
    :param gif_loop: None for no loop, otherwise the framenumber to go to after the last frame
    :return: the temp dir where the frames are stored
    """
    ...

def screenshot(width=..., height=..., format=..., fig=..., timeout_seconds=..., output_widget=..., headless=..., devmode=...): # -> Image:
    """Save the figure to a PIL.Image object.

    :param int width: the width of the image in pixels
    :param int height: the height of the image in pixels
    :param format: format of output data (png, jpeg or svg)
    :type fig: ipyvolume.widgets.Figure or None
    :param fig: if None use the current figure
    :type timeout_seconds: int
    :param timeout_seconds: maximum time to wait for image data to return
    :type output_widget: ipywidgets.Output
    :param output_widget: a widget to use as a context manager for capturing the data
    :param bool headless: if True, use headless chrome to take screenshot
    :param bool devmode: if True, attempt to get index.js from local js/dist folder
    :return: PIL.Image

    """
    ...

def savefig(filename, width=..., height=..., fig=..., timeout_seconds=..., output_widget=..., headless=..., devmode=...): # -> None:
    """Save the figure to an image file.

    :param str filename: must have extension .png, .jpeg or .svg
    :param int width: the width of the image in pixels
    :param int height: the height of the image in pixels
    :type fig: ipyvolume.widgets.Figure or None
    :param fig: if None use the current figure
    :param float timeout_seconds: maximum time to wait for image data to return
    :param ipywidgets.Output output_widget: a widget to use as a context manager for capturing the data
    :param bool headless: if True, use headless chrome to save figure
    :param bool devmode: if True, attempt to get index.js from local js/dist folder
    """
    ...

def xlabel(label): # -> None:
    """Set the labels for the x-axis"""
    ...

def ylabel(label): # -> None:
    """Set the labels for the y-axis"""
    ...

def zlabel(label): # -> None:
    """Set the labels for the z-axis"""
    ...

def xyzlabel(labelx, labely, labelz): # -> None:
    """Set all labels at once"""
    ...

def view(azimuth=..., elevation=..., distance=...): # -> tuple[Any | Unknown, Any | Unknown, Any | Unknown]:
    """Sets camera angles and distance and returns the current.

    :param float azimuth: rotation around the axis pointing up in degrees
    :param float elevation: rotation where +90 means 'up', -90 means 'down', in degrees
    :param float distance: radial distance from the center to the camera.
    """
    ...

class style:
    """'Static class that mimics a matplotlib module.

    Example:

    >>> import ipyvolume as ipv
    >>> ipv.style.use('light'])
    >>> ipv.style.use('seaborn-darkgrid'])
    >>> ipv.style.use(['seaborn-darkgrid', {'axes.x.color':'orange'}])

    Possible style values:
     * figure.facecolor: background color
     * axes.color: color of the box around the volume/viewport
     * xaxis.color: color of xaxis
     * yaxis.color: color of xaxis
     * zaxis.color: color of xaxis

    """
    @staticmethod
    def use(style): # -> None:
        """Set the style of the current figure/visualization

        :param style: matplotlib style name, or dict with values, or a sequence of these, where the last value overrides previous
        :return:
        """
        ...
    
    @staticmethod
    def axes_off(): # -> None:
        """Do not draw the axes"""
        ...
    
    @staticmethod
    def axes_on(): # -> None:
        """Draw the axes"""
        ...
    
    @staticmethod
    def box_off(): # -> None:
        """Do not draw the box around the visible volume"""
        ...
    
    @staticmethod
    def box_on(): # -> None:
        """Draw a box around the visible volume"""
        ...
    
    @staticmethod
    def background_color(color): # -> None:
        """Sets the background color"""
        ...
    


@_docsubst
def plot_plane(where=..., texture=...): # -> Mesh:
    """Plots a plane at a particular location in the viewbox

    :param str where: 'back', 'front', 'left', 'right', 'top', 'bottom'
    :param texture: {texture}
    :return: :any:`Mesh`
    """
    ...

def selector_default(output_widget=...): # -> None:
    """Capture selection events from the current figure, and apply the selections to Scatter objects

    Example:

    >>> import ipyvolume as ipv
    >>> ipv.figure()
    >>> ipv.examples.gaussian()
    >>> ipv.selector_default()
    >>> ipv.show()

    Now hold the control key to do selections, type

      * 'C' for circle
      * 'R' for rectangle
      * 'L' for lasso
      * '=' for replace mode
      * '&' for logically and mode
      * '|' for logically or mode
      * '-' for subtract mode

    """
    ...


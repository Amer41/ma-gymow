"""
This type stub file was generated by pyright.
"""

import ipywidgets as widgets
import ipywebrtc
from .transferfunction import *
from .utils import debounced

logger = ...
_last_volume_renderer = ...
semver_range_frontend = ...
@widgets.register
class Mesh(widgets.Widget):
    _view_name = ...
    _view_module = ...
    _model_name = ...
    _model_module = ...
    _view_module_version = ...
    _model_module_version = ...
    x = ...
    y = ...
    z = ...
    u = ...
    v = ...
    triangles = ...
    lines = ...
    texture = ...
    sequence_index = ...
    color = ...
    visible = ...
    material = ...
    line_material = ...


@widgets.register
class Scatter(widgets.Widget):
    _view_name = ...
    _view_module = ...
    _model_name = ...
    _model_module = ...
    _view_module_version = ...
    _model_module_version = ...
    x = ...
    y = ...
    z = ...
    vx = ...
    vy = ...
    vz = ...
    selected = ...
    sequence_index = ...
    size = ...
    size_selected = ...
    color = ...
    color_selected = ...
    geo = ...
    connected = ...
    visible = ...
    texture = ...
    material = ...
    line_material = ...


@widgets.register
class Volume(widgets.Widget):
    """Widget class representing a volume (rendering) using three.js"""
    _view_name = ...
    _view_module = ...
    _model_name = ...
    _model_module = ...
    _view_module_version = ...
    _model_module_version = ...
    data = ...
    data_original = ...
    data_max_shape = ...
    data_min = ...
    data_max = ...
    show_min = ...
    show_max = ...
    clamp_min = ...
    clamp_max = ...
    opacity_scale = ...
    brightness = ...
    tf = ...
    ray_steps = ...
    rendering_method = ...
    lighting = ...
    extent = ...
    extent_original = ...
    def __init__(self, **kwargs) -> None:
        ...
    
    @debounced(method=True)
    def update_data(self, change=...): # -> None:
        ...
    


@widgets.register
class Figure(ipywebrtc.MediaStream):
    """Widget class representing a volume (rendering) using three.js"""
    _view_name = ...
    _view_module = ...
    _model_name = ...
    _model_module = ...
    _view_module_version = ...
    _model_module_version = ...
    eye_separation = ...
    scatters = ...
    meshes = ...
    volumes = ...
    animation = ...
    animation_exponent = ...
    ambient_coefficient = ...
    diffuse_coefficient = ...
    specular_coefficient = ...
    specular_exponent = ...
    stereo = ...
    camera_control = ...
    camera_fov = ...
    camera_center = ...
    camera = ...
    scene = ...
    width = ...
    height = ...
    downscale = ...
    displayscale = ...
    capture_fps = ...
    cube_resolution = ...
    show = ...
    xlim = ...
    ylim = ...
    zlim = ...
    matrix_projection = ...
    matrix_world = ...
    xlabel = ...
    ylabel = ...
    zlabel = ...
    style = ...
    render_continuous = ...
    selector = ...
    selection_mode = ...
    mouse_mode = ...
    panorama_mode = ...
    def __init__(self, **kwargs) -> None:
        ...
    
    def __enter__(self): # -> None:
        """Sets this figure as the current in the pylab API

        Example:
        >>> f1 = ipv.figure(1)
        >>> f2 = ipv.figure(2)
        >>> with f1:
        >>>  ipv.scatter(x, y, z)
        >>> assert ipv.gcf() is f2
        """
        ...
    
    def __exit__(self, type, value, traceback): # -> None:
        ...
    
    def screenshot(self, width=..., height=..., mime_type=...): # -> None:
        ...
    
    def on_screenshot(self, callback, remove=...): # -> None:
        ...
    
    def on_selection(self, callback, remove=...): # -> None:
        ...
    
    def project(self, x, y, z): # -> Any:
        ...
    


def volshow(*args, **kwargs): # -> None:
    """Deprecated: please use ipyvolume.quickvolshow or use the ipyvolume.pylab interface"""
    ...

def quickquiver(x, y, z, u, v, w, **kwargs): # -> None:
    ...

def quickscatter(x, y, z, **kwargs): # -> None:
    ...

def quickvolshow(data, lighting=..., data_min=..., data_max=..., max_shape=..., level=..., opacity=..., level_width=..., extent=..., memorder=..., **kwargs): # -> None:
    """
    Visualize a 3d array using volume rendering

    :param data: 3d numpy array
    :param lighting: boolean, to use lighting or not, if set to false, lighting parameters will be overriden
    :param data_min: minimum value to consider for data, if None, computed using np.nanmin
    :param data_max: maximum value to consider for data, if None, computed using np.nanmax
    :parap int max_shape: maximum shape for the 3d cube, if larger, the data is reduced by skipping/slicing (data[::N]), set to None to disable.
    :param extent: list of [[xmin, xmax], [ymin, ymax], [zmin, zmax]] values that define the bounds of the volume, otherwise the viewport is used
    :param level: level(s) for the where the opacity in the volume peaks, maximum sequence of length 3
    :param opacity: opacity(ies) for each level, scalar or sequence of max length 3
    :param level_width: width of the (gaussian) bumps where the opacity peaks, scalar or sequence of max length 3
    :param kwargs: extra argument passed to Volume and default transfer function
    :return:

    """
    ...

def scatter(x, y, z, color=..., s=...): # -> None:
    ...

